Approach:
    - we will display the calls in a grid, joining related Customer and Agent data.
    - relations between tables are as follows:
        - Customer to calls: 1 to many
        - Agent to calls: 1 to many
        - Customer to Agent: 1 to many
    - we display the grid in Blade view.
    - view gets the through CallController
    - filters are passed in the following format:
        filter[modelName][field] = value
        in query param:
        ?filter[Customer][name]=John&filter[Agent][id]=2
    - data is fetched through endpoint /.

    - on load, the data is fetched from the database.
        user can select the filters he wants, that are generated by the backend in a generic way, according to selected model.
        filters for date and agent (by id) are hardcoded.

Assumptions:
    - currently, we don't need any many-to-many relationship between the tables.
        I assumed Customer can be assigned to only one Agent, and call can be assigned to only one Customer and Agent.
        If it wasn't the case, we would have to create a pivot table for many-to-many relationships.
    - I know its bad that page refreshes with each request!
        I left it like that because the task is supposed to be short. would've used AJAX or Laravel wire otherwise.

Steps taken:
    - understanding the task.
    - thinking about relations between models.
    - figure out the approach, how the data flows.
    - create models, controllers, migrations.
    - create relations between models.
    - create the routes and endpoints.
    - finish CallController logic, create filterService.
    - create views - blade templates: index, grid and filters.
    - create dummy data.
    - clean up the code.

BONUS: Ways of increasing the performance:
    - indexing: id is indexed by default in laravel. Also indexed create_at
    - caching: added cache to agents make repeated requests faster. We can add it to call query as well. We can also add cache in the frontend.
    - pagination: could add frontend pagination, so it won't send a request to the backend with each page.
    - chunking: we could chunk the data in the backend, so it doesn't load all the data at once.
    - frontend lazy loading: could load the data as the user scrolls down, instead of paginating.
    - optimizing queries: used inner join instead of eloquent relations to make the query faster.
